# 🎬 Netflix Data Visualization: 환경 설정 및 도구 준비

## 📌 코드 개요
이 코드는 데이터 분석 및 시각화 프로젝트를 시작하기 위해 **필요한 도구(라이브러리)들을 불러오고**, 분석 환경(그래프 해상도, 오프라인 모드 등)을 **최적화하는 단계**입니다.

---

## 🛠️ 라이브러리 상세 분석

### 1. 데이터 처리 및 기본 연산
* **pandas (`pd`)**: 데이터프레임(표)을 다루는 필수 도구. 넷플릭스 csv 파일을 불러오고 가공하는 데 사용합니다.
* **numpy (`np`)**: 수치 연산 및 배열 처리를 위한 라이브러리입니다.

### 2. 머신러닝 (Clustering)
이번 프로젝트는 '정답을 맞추는(예측)' 것이 아니라 **'데이터를 그룹 짓는(군집화)'** 것이 목표임을 알 수 있습니다.
* **sklearn.preprocessing (`StandardScaler`)**: 데이터의 단위를 통일(스케일링)하여 거리 계산을 공평하게 만듭니다.
* **sklearn.cluster (`KMeans`, `AffinityPropagation`)**:
    * `KMeans`: 가장 대표적인 군집화 알고리즘. 데이터를 K개의 그룹으로 묶습니다.
    * `AffinityPropagation`: 데이터 간의 '친밀도'를 기반으로 그룹을 만드는 알고리즘입니다.

### 3. 정적 시각화 (Static Visualization)
* **matplotlib.pyplot (`plt`)**: 파이썬의 기본 시각화 도구입니다.
* **seaborn (`sns`)**: matplotlib을 더 예쁘고 쓰기 편하게 만든 상위 호환 도구입니다.
* **%matplotlib inline**: (주피터 노트북 전용) 그래프를 별도의 창이 아닌 노트북 셀 바로 아래에 출력하게 하는 매직 커맨드입니다.

### 4. 동적 시각화 (Interactive Visualization) ⭐
이번 프로젝트의 **핵심 무기**입니다. 마우스 상호작용이 가능한 그래프를 그립니다.
* **plotly (`py`)**: 인터랙티브 그래프 라이브러리.
* **plotly.graph_objs (`go`)**: 그래프 객체(Bar, Scatter 등)를 생성하는 모듈.
* **py.offline.init_notebook_mode(connected=True)**:
    * 인터넷이 연결된 상태에서 노트북 내에 그래프가 정상적으로 표시되도록 초기화합니다.

### 5. 유틸리티 (Utilities)
* **warnings**: `warnings.filterwarnings("ignore")`를 통해 버전 호환성 등으로 인한 빨간색 경고 메시지를 숨겨줍니다. (화면을 깔끔하게 유지)
* **os**: 파일 경로를 찾거나 운영체제와 상호작용할 때 사용합니다.
* **datetime (`dt`)**: 날짜 데이터(예: 개봉일)를 처리하기 위해 사용합니다.
* **missingno (`msno`)**: 데이터의 **결측치(빈칸)** 분포를 바코드 형태 등으로 시각화해주는 유용한 도구입니다.

---

## ⚙️ 환경 설정 포인트

### 1. 그래프 해상도 업그레이드
```python
plt.rcParams['figure.dpi'] = 140

# 🧹 데이터 전처리 및 파생 변수 생성 (Preprocessing)

## 📌 코드 개요
결측치(빈칸)를 전략적으로 채우거나 제거하고, 문자열로 되어 있는 날짜 데이터를 **분석 가능한 날짜 형식(Datetime)**으로 변환하여 새로운 변수(`Year`, `Month`)를 생성하는 단계입니다.

```python
# Replacements (채우기)
df['country'] = df['country'].fillna(df['country'].mode()[0])
df['cast'].replace(np.nan, 'No Data', inplace=True)
df['director'].replace(np.nan, 'No Data', inplace=True)

# Drops (제거하기)
df.dropna(inplace=True)
df.drop_duplicates(inplace=True)

# Date Feature Engineering (날짜 변수 가공)
df["date_added"] = pd.to_datetime(df['date_added'])
df['month_added'] = df['date_added'].dt.month
df['month_name_added'] = df['date_added'].dt.month_name()
df['year_added'] = df['date_added'].dt.year

# 🎨 브랜딩 및 타임라인 시각화 (Storytelling)

## 📌 코드 개요
본격적인 데이터 분석에 앞서, **넷플릭스 고유의 브랜드 컬러**를 시각화하고, 주요 연혁을 **타임라인 그래프**로 그려 독자에게 배경지식을 전달하는 단계입니다.

---

## 1️⃣ 넷플릭스 브랜드 팔레트 (Brand Palette)

시각화의 통일성을 위해 넷플릭스를 상징하는 **검정, 빨강, 흰색** 조합을 미리 정의하고 확인합니다.

```python
# Palettes
sns.palplot(['#221f1f', '#b20710', '#e50914', '#f5f5f1'])
plt.title("Netflix brand palette ", loc='left', fontfamily='serif', fontsize=15, y=1.2)
plt.show()

# 🎨 타임라인 디테일 완성 & 콘텐츠 비율 분석

## 📌 코드 개요
1.  **타임라인 완성**: 앞서 그린 뼈대 위에 `stem`(줄기) 그래프를 사용하여 세부적인 사건들을 위아래로 배치하고, 텍스트와 제목을 달아 인포그래픽을 완성합니다.
2.  **데이터 분석 시작**: 넷플릭스 데이터셋에서 **영화(Movie)와 TV쇼(TV Show)의 비율**을 계산하여 다음 시각화를 준비합니다.

---

## 1️⃣ 타임라인 디테일 (Stem Plot & Annotation)

단조로운 타임라인에 입체감을 주기 위해 수직선(Stem)을 활용합니다.

### 🛠️ 코드 상세 분석

#### **1. 줄기(Stem) 만들기**
```python
levels = np.zeros(len(tl_sub_x))
levels[::2] = 0.3   # 짝수 번째는 위로 (+0.3)
levels[1::2] = -0.3 # 홀수 번째는 아래로 (-0.3)
markerline, stemline, baseline = ax.stem(tl_sub_x, levels, use_line_collection=True)
# 1.3*(idx%2)-0.5: 이 수식은 짝수/홀수 순서에 따라 글자 위치를 위아래로 자동 조절해 줍니다. 노가다를 줄여주는 스마트한 코드입니다.
# Spine 제거: ax.spines[spine].set_visible(False)로 그래프의 네모난 테두리를 다 지워서 깔끔한 포스터처럼 만듭니다.

# 📊 콘텐츠 비율 시각화 (Stacked Bar Chart)

## 📌 코드 개요
파이 차트 대신 **가로형 스택 바 차트**를 사용하여 Movie와 TV Show의 비율을 직관적인 **'프로그레스 바(Progress Bar)'** 형태로 시각화합니다.

## 🛠️ 시각화 기법 (Visualization Techniques)

### 1. Stacked Bar (쌓아 올리기)
* `ax.barh`: 가로 막대그래프를 그립니다.
* **`left` 파라미터**: 두 번째 막대(TV Show)의 시작점을 첫 번째 막대(Movie)의 끝지점으로 설정하여, 하나의 긴 막대처럼 연결되게 만듭니다.

### 2. Annotation (텍스트 좌표 계산)
그래프 위에 글자를 쓸 때, 정확히 **각 색상 영역의 정중앙**에 오도록 좌표를 계산했습니다.
* **Movie 텍스트**: `Movie길이 / 2`
* **TV Show 텍스트**: `Movie길이 + (TV Show길이 / 2)`

### 3. Data-Ink Ratio 최적화 (불필요한 요소 제거)
* `ax.set_xticks([])`, `ax.set_yticks([])`: X축, Y축의 눈금을 모두 제거합니다.
* `ax.spines[s].set_visible(False)`: 그래프의 네모난 테두리(Spine)를 모두 지웁니다.
* **효과**: 오직 **색상과 숫자**에만 집중하게 만드는 세련된 디자인입니다.

## 💡 디자인 포인트
* **Color**: 앞서 지정한 넷플릭스 브랜드 컬러(빨강, 검정)를 사용하여 통일감을 주었습니다.
* **Typography**: 제목과 설명(Subtitle)을 그래프 상단에 배치하여 신문 기사 같은 느낌을 줍니다.

# 🛠️ Feature Engineering (데이터 가공)

## 📌 코드 개요
시각화를 더 깔끔하고 직관적으로 만들기 위해 기존 데이터를 **단순화(Simplification)하고 그룹화(Grouping)**하는 단계입니다.

## ⚙️ 주요 기법 분석

### 1. 주요 제작국가 추출 (`first_country`)
* **상황**: `country` 컬럼에 여러 국가가 섞여 있음 (예: "US, UK, France").
* **처리**: `apply(lambda x: x.split(",")[0])`를 사용하여 **가장 앞에 적힌 국가 하나**만 추출.
* **목적**: 복잡한 다중 국가 데이터를 단일 국가로 바꿔 시각화를 단순화함.

### 2. 관람 등급 재분류 (`target_ages`)
* **상황**: `TV-MA`, `R`, `PG-13` 등 등급 분류가 너무 세분화되어 있어 한눈에 보기 힘듦.
* **처리**: 딕셔너리 매핑(`map`)을 통해 4가지 큰 범주로 통합.
    * **Adults**: 성인 (TV-MA, R, NC-17 등)
    * **Teens**: 청소년 (TV-14, PG-13)
    * **Older Kids**: 고학년 아동 (TV-PG, PG)
    * **Kids**: 영유아 및 저학년 (TV-Y, TV-G)
* **효과**: 분석의 단위를 줄여서(Dimension Reduction) **"타겟 연령층"**을 명확히 파악할 수 있게 됨.

### 3. 데이터 라벨링 최적화 (`replace`)
* **처리**: `United States` → `USA`, `South Korea` → `S. Korea` 등 국가명을 짧게 변경.
* **목적**: 그래프의 X축/Y축 라벨이 길어서 글자가 겹치는 현상을 방지. (가독성 향상)

### 4. 장르 데이터 정제 (`genre`)
* **처리**: `listed_in` 컬럼의 지저분한 공백을 제거하고 리스트 형태로 변환.
* **코드**: `.replace(' ,',',')` (오타 수정) → `.split(',')` (리스트 변환).

---

## 💡 분석 인사이트
이 과정은 단순한 전처리가 아니라 **"분석가의 의도"**가 들어간 과정입니다.
* "합작 영화라도 **메인 국가**만 보겠다."
* "세부 등급보다는 **성인용인지 아동용인지**가 더 중요하다."
라는 가설을 세우고 데이터를 그에 맞춰 재설계한 것입니다.

# 📊 국가별 콘텐츠 생산량 Top 10 (Bar Chart with Storytelling)

## 📌 코드 개요
전처리가 완료된 데이터에서 **콘텐츠 생산량이 가장 많은 상위 10개국**을 추출하여 막대그래프로 시각화합니다.
단순 나열이 아니라, **상위 3개국(USA, India, UK)**을 넷플릭스 브랜드 컬러(Red)로 강조하고, 그래프 오른쪽에 **분석 결과(Insight)**를 텍스트로 추가하여 보고서 같은 느낌을 줍니다.

---

## 🛠️ 시각화 기법 분석 (Visualization Techniques)

### 1. 데이터 집계 (Data Aggregation)
```python
data = df.groupby('first_country')['count'].sum().sort_values(ascending=False)[:10]

# 📊 국가별 콘텐츠 구성 비율 (Percent Stacked Bar Chart)

## 📌 코드 개요
상위 10개국(생산량 기준)을 대상으로, 각 나라의 넷플릭스 콘텐츠가 **영화(Movie)와 TV쇼(TV Show) 중 어디에 치중되어 있는지**를 비율(%)로 시각화합니다.
단순 개수 비교가 아니라 **합이 1(100%)인 비율 그래프**를 그려서, 국가별 성향 차이를 명확하게 비교합니다.

---

## 🛠️ 데이터 가공 및 시각화 기법

### 1. 비율 데이터 계산 (Data Preparation)
```python
# 1. 교차표 만들기 (Unstack)
data_q2q3 = df[['type', 'first_country']].groupby('first_country')['type']\
    .value_counts().unstack().loc[country_order]

# 2. 합계 계산
data_q2q3['sum'] = data_q2q3.sum(axis=1)

# 3. 비율 계산 (각 값을 합계로 나눔)
data_q2q3_ratio = (data_q2q3.T / data_q2q3['sum']).T[['Movie', 'TV Show']]

# 4. 정렬 (영화 비중이 높은 순서대로)
data_q2q3_ratio.sort_values(by='Movie', ascending=False)[::-1]

# 📊 등급별 분포 비교 (Bi-directional Bar Chart)

## 📌 코드 개요
넷플릭스의 관람 등급(`rating`) 분포를 시각화합니다.
단순히 막대 두 개를 나란히 놓는 것이 아니라, **영화는 위로(Up), TV쇼는 아래로(Down)** 뻗어나가게 그려서 두 카테고리의 **대칭성과 차이점**을 직관적으로 보여줍니다.

---

## 🛠️ 시각화 기법 분석 (Visualization Techniques)

### 1. 데이터 준비 (Data Preparation)
```python
# 1. 전체 순위 정하기 (Sorting)
order = pd.DataFrame(df.groupby('rating')['count'].sum().sort_values(ascending=False).reset_index())
rating_order = list(order['rating']) 

# 2. 데이터 구조 변환 (Unstack)
mf = df.groupby('type')['rating'].value_counts().unstack().sort_index().fillna(0).astype(int)[rating_order]

# 📈 연도별 콘텐츠 추가 추이 (Area Chart)

## 📌 코드 개요
`year_added` 데이터를 활용하여 연도별로 영화와 TV쇼가 얼마나 많이 등록되었는지 시계열로 시각화합니다.
단순 선 그래프(`plot`) 아래에 색을 채우는(`fill_between`) 기법을 사용하여, 콘텐츠의 양적 성장을 산(Mountain)처럼 표현했습니다.

---

## 🛠️ 시각화 기법 분석 (Visualization Techniques)

### 1. 영역 채우기 (Fill Between) ⭐
이 코드의 핵심입니다. 선만 그리면 빈약해 보일 수 있는데, 아래를 색으로 채워 무게감을 줍니다.
```python
ax.plot(mtv_rel.index, mtv_rel, color=color[i], label=mtv) # 1. 선 그리기
ax.fill_between(mtv_rel.index, 0, mtv_rel, color=color[i], alpha=0.9) # 2. 색 채우기

# 📈 연도별 누적 콘텐츠 추이 (Stacked Area Chart)

## 📌 코드 개요
연도별 콘텐츠 추가량을 시각화하되, 영화와 TV쇼를 **쌓아 올려서(Stacked)** 표현했습니다.
* **높이(Height)**: 해당 연도에 추가된 콘텐츠의 **총 개수** (Movie + TV Show).
* **색상(Color)**: 전체 중에서 각 타입이 차지하는 **비중**.

## 🛠️ 시각화 기법 분석 (Visualization Techniques)

### 1. 누적 합 계산 (Cumulative Sum) ⭐
이 코드의 핵심 트릭입니다. `plt.stackplot`을 쓰지 않고 수동으로 쌓아 올렸습니다.
```python
data_sub = df.groupby('type')['year_added'].value_counts().unstack().fillna(0).loc[['TV Show','Movie']].cumsum(axis=0).T

# 📅 월별 콘텐츠 추가 패턴 (Seasonal Trends)

## 📌 코드 개요
1월부터 12월까지 월별 콘텐츠 등록량을 집계하여 **누적 영역 차트(Stacked Area Chart)**로 시각화합니다.
넷플릭스가 특정 시즌(예: 연말연시)에 집중적으로 콘텐츠를 공개하는지, 마케팅 전략을 엿볼 수 있습니다.

---

## 🛠️ 시각화 기법 및 테크닉

### 1. 범주형 데이터 정렬 (Categorical Sorting) ⭐
이 부분이 가장 중요합니다! 컴퓨터는 기본적으로 알파벳 순서(April -> August...)로 정렬하려 합니다.
이를 **시간 순서(January -> February...)**로 강제하기 위해 `pd.Categorical`을 사용했습니다.

```python
# 1. 원하는 순서를 리스트로 정의
month_order = ['January', 'February', ... 'December']

# 2. 순서가 있는 범주형 데이터로 변환 (ordered=True)
df['month_name_added'] = pd.Categorical(df['month_name_added'], categories=month_order, ordered=True)

# 🎡 월별 콘텐츠 분포 (Circular Bar Plot)

## 📌 코드 개요
1월부터 12월까지의 콘텐츠 추가량을 **시계 모양의 원형 막대그래프**로 시각화합니다.
일반적인 막대그래프보다 데이터 비교는 조금 어렵지만, **"계절성(Seasonality)과 순환"**을 강조하고 시각적으로 매우 아름다워서 포트폴리오의 **메인 이미지**로 쓰기 좋습니다.

---

## 🛠️ 시각화 기법: 극좌표계 (Polar Coordinates)

이 그래프의 핵심은 네모난 `x, y` 좌표계가 아니라, **각도(Angle)와 거리(Radius)**를 쓰는 **극좌표계**를 사용한다는 점입니다.

### 1. 캔버스 설정 (`polar=True`) ⭐
```python
ax = plt.subplot(111, polar=True)
plt.axis('off')

# 🔥 장르 간 상관관계 히트맵 (Genre Correlation Heatmap)

## 📌 코드 개요
한 영화가 여러 장르(`Action, Adventure, Sci-Fi`)를 가질 수 있다는 점에 착안하여, 장르들이 **서로 얼마나 자주 함께 등장하는지** 상관계수를 분석합니다.
* **양의 상관관계 (Red)**: 같이 자주 등장함 (예: 로맨스 + 드라마)
* **음의 상관관계 (Black)**: 같이 등장하는 일이 거의 없음 (예: 공포 + 키즈)

---

## 🛠️ 핵심 분석 기법 (Advanced Techniques)

### 1. 멀티 라벨 인코딩 (`MultiLabelBinarizer`) ⭐
이 코드의 심장부입니다. 컴퓨터는 "Action, Comedy"라는 글자를 계산할 수 없습니다. 이를 0과 1의 숫자로 바꿔줘야 합니다.

```python
# Before: ['Action', 'Comedy']
# After: Action=1, Comedy=1, Drama=0, Horror=0 ...

mlb = MultiLabelBinarizer()
res = pd.DataFrame(mlb.fit_transform(test), ...) 

# 🎯 국가별 타겟 연령층 분석 (Country vs Target Age Heatmap)

## 📌 코드 개요
1.  **영화 장르 히트맵**: 앞서 정의한 함수를 사용하여 '영화(Movie)' 데이터만 따로 장르 간 상관관계를 확인합니다.
2.  **국가별 연령 분포 히트맵**: 상위 10개국이 **어떤 연령대(Kids, Teens, Adults)**를 주 타겟으로 삼고 있는지 비율(%)로 시각화합니다.

---

## 🛠️ 핵심 데이터 처리 기법

### 1. 교차 분석표 (`pd.crosstab`) ⭐
이 코드의 하이라이트입니다. 두 범주형 변수의 관계를 표로 만들어줍니다.

```python
df_heatmap = pd.crosstab(
    df_heatmap['first_country'],  # 행(Row): 국가
    df_heatmap['target_ages'],    # 열(Col): 연령대
    normalize="index"             # 정규화: 행(국가)별 합계가 1(100%)이 되도록 변환
).T

# ⏳ 영화의 신선도 측정 (Dumbbell Plot)

## 📌 코드 개요
국가별로 영화의 **'평균 개봉 연도(Release Year)'**와 넷플릭스 **'평균 등록 연도(Added Year)'**를 계산하여 비교합니다.
이 두 시점 사이의 거리가 멀수록 "옛날 영화를 많이 사왔다"는 뜻이고, 가까울수록 "최신 영화를 빨리 가져왔다"는 뜻입니다.

---

## 🛠️ 시각화 기법: 덤벨 차트 (Dumbbell Plot)

이 차트는 `matplotlib`에 `dumbbell`이라는 함수가 따로 없습니다. 그래서 **선(Line)과 점(Scatter)을 따로 그려서 합치는 방식**으로 구현합니다.

### 1. 데이터 준비 (Data Prep)
```python
loli = df_loli.groupby('first_country')['release_year','year_added'].mean().round()

# ⏳ TV 쇼의 신선도 측정 (Dumbbell Plot - TV Show Ver.)

## 📌 코드 개요
앞서 영화 데이터(`df_movies`)로 그렸던 덤벨 차트를, 이번에는 **TV 쇼 데이터(`df_tv`)**에 적용하여 비교 분석합니다.
영화와 달리 TV 쇼는 **'시즌제(Seasonal)'**라는 특성이 있어서, 개봉일과 등록일 사이의 간격(Gap) 패턴이 다르게 나타납니다.

---

## 🛠️ 차트 비교 분석 (Movie vs TV Show)

코드는 동일하지만 결과물의 형태(패턴)가 다릅니다. 이 차이를 읽어내는 것이 데이터 분석가의 능력입니다.

### 1. 간격의 차이 (The Gap)
* **영화(Movie)**: 간격이 들쑥날쑥합니다. 1970년 고전 영화가 2020년에 들어오면 간격이 50년이나 되기 때문입니다.
* **TV 쇼(TV Show)**: 회색 선(Gap)의 길이가 상대적으로 **짧고 일정**합니다.
    * **이유**: 드라마나 예능은 매년 새로운 시즌이 나오면(Released), 넷플릭스에 금방 업데이트(Added)되기 때문입니다. 즉, **신선도가 높습니다.**

### 2. 국가별 특징 (Country Insight)
* **🇪🇸 스페인 (Spain)**: 영화뿐만 아니라 TV 쇼에서도 가장 **오른쪽(최신)**에 위치하며, 간격이 매우 짧습니다. 넷플릭스 스페인 콘텐츠는 대부분 **'최신 유행작'**임을 다시 한번 확인할 수 있습니다.

---

## 💡 분석 인사이트 (Key Finding)

> "The gap for TV shows seems more regular than for movies."

저자가 코드 내 텍스트(`fig.text`)에 적어놓은 이 문장이 핵심입니다.
TV 쇼는 **Year-on-Year (매년)** 새로운 시즌이 공개되는 구조이기 때문에, 넷플릭스 라이브러리 업데이트 주기도 그에 맞춰 **규칙적**으로 돌아가고 있음을 시각적으로 증명했습니다.

# 🇺🇸 USA vs 🇮🇳 India: 성장 속도 비교 (Layered Area Chart)

## 📌 코드 개요
전체 데이터 중 상위 2개국인 **미국(USA)**과 **인도(India)**만 따로 뽑아서(`us_ind`), 연도별 콘텐츠 추가량을 비교합니다.
두 개의 영역 차트를 겹쳐서 그리는 방식을 사용했습니다.

---

## 🛠️ 시각화 기법 (Visualization Techniques)

### 1. 데이터 필터링 (Filtering)
```python
us_ind = df[(df['first_country'] == 'USA') | (df['first_country'] == 'India')]

# 🌊 USA vs 🇮🇳 India: 스트림 그래프 (Stream Graph)

## 📌 코드 개요
미국과 인도의 연도별 콘텐츠 추가량을 **중심축(0)을 기준으로 위아래로 대칭**되게 시각화했습니다.
일반적인 영역 차트보다 **"거대한 흐름"**과 **"상대적인 압도감"**을 시각적으로 강렬하게 전달합니다.

---

## 🛠️ 시각화 기법: 중심 맞추기 (Centering Logic)

이 그래프의 핵심은 **"어떻게 그래프를 바닥에서 띄워서 중앙에 오게 했느냐"**입니다. 수학적인 트릭이 숨어있습니다.

### 1. 베이스라인 이동 (Shifting the Baseline) ⭐
```python
# 1. 전체 높이의 절반(1/2)만큼 아래로 내림
data_sub = data_sub.add(-us_ind['year_added'].value_counts()/2, axis=0)

# ☁️ 넷플릭스 제목 워드 클라우드 (Word Cloud with Mask)

## 📌 코드 개요
넷플릭스 콘텐츠들의 **제목(Title)**에 가장 많이 쓰인 단어들을 추출하여 시각화합니다.
단순히 네모난 틀에 넣는 것이 아니라, 외부 이미지(넷플릭스 아이콘)를 **마스크(Mask)**로 사용하여 그 모양대로 단어를 배치하는 고급 기법입니다.

---

## 🛠️ 핵심 구현 기법 (Key Techniques)

### 1. 텍스트 전처리 (Text Cleaning)
```python
text = str(list(df['title'])).replace(',', '').replace('[', '')...