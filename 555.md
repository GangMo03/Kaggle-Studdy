# 2. 데이터 핸들링 및 연산
from dateutil import parser 택시 탑승 시간(pickup_datetime)에서 **'시간(hour)'**이나 '요일' 정보를 뽑아내기 위해 사용
from imblearn.under_sampling import RandomUnderSampler 전체 데이터의 분포(Distribution)는 유지하면서 데이터 개수만 확 줄여서 가볍게 만들기 위함

# 3. 시각화 및 애니메이션
from matplotlib import animation 정지된 그래프(Plot)를 여러 장 연속으로 그려서 **동영상(GIF, MP4)**처럼 만들어주는 도구
from matplotlib import cm 숫자 데이터의 크기에 따라 **색상(Color)**을 자동으로 입혀주는 도구
# --- 데이터 파일 확인 ---
# 1. 뉴욕시(맨해튼 중심)의 경도(x)와 위도(y) 범위 설정
xlim = [-74.03, -73.77] # Longitude boundary (West to East)
ylim = [40.63, 40.85]   # Latitude boundary (South to North)

# 2. 승차(Pickup) 및 하차(Dropoff) 위치가 설정된 범위 내에 있는 데이터만 필터링
# 경도(Longitude) 필터링
df = df[(df.pickup_longitude > xlim[0]) & (df.pickup_longitude < xlim[1])]
df = df[(df.dropoff_longitude > xlim[0]) & (df.dropoff_longitude < xlim[1])]
# 위도(Latitude) 필터링
# 1. 승차(Pickup) 및 하차(Dropoff) 좌표 데이터를 하나의 리스트로 통합
# 목적: 모든 위치 데이터를 한 번에 시각화하여 뉴욕의 전체 도로망 확인
longitude = list(df.pickup_longitude) + list(df.dropoff_longitude)
latitude = list(df.pickup_latitude) + list(df.dropoff_latitude)
# 3. 산점도 그리기
# 2. K-Means 클러스터링 모델 학습 (15개 구역으로 분류)
# n_clusters=15: 15개의 그룹으로 나눔
# n_init=10: 초기 중심점 설정을 10번 반복하여 최적의 결과 도출
kmeans = KMeans(n_clusters=15, random_state=2, n_init=10).fit(loc_df)

# 3. 각 데이터에 클러스터 라벨(0~14) 부여
loc_df['label'] = kmeans.labels_
# 4. 시각화를 위해 20만 개 샘플링 (전체 데이터는 너무 무거움)
loc_df = loc_df.sample(200000)
# 5. 클러스터별 시각화 (각 구역을 다른 색으로 표현)
plt.figure(figsize = (10,10))
for label in loc_df.label.unique():
    # 해당 라벨(구역)에 속하는 데이터만 필터링하여 plot
    plt.plot(loc_df.longitude[loc_df.label == label],
             loc_df.latitude[loc_df.label == label],
             '.', alpha = 0.3, markersize = 0.3)

# --- 1. 클러스터 중심점(Centroid) 시각화 ---
fig, ax = plt.subplots(figsize = (10, 10))

for label in loc_df.label.unique():
    # 1) 배경: 해당 클러스터에 속하는 실제 데이터 점 (회색)
    ax.plot(loc_df.longitude[loc_df.label == label],
            loc_df.latitude[loc_df.label == label],
            '.', alpha = 0.4, markersize = 0.1, color = 'gray')

    # 2) 중심점: 해당 클러스터의 중심 좌표 (빨간색 큰 점)
    # cluster_centers_[label, 0] = 경도(x), [label, 1] = 위도(y)
    ax.plot(kmeans.cluster_centers_[label, 0],
            kmeans.cluster_centers_[label, 1],
            'o', color = 'r')

    # 3) 라벨링: 중심점 옆에 클러스터 번호(0~14) 텍스트 표시
    ax.annotate(label, 
                (kmeans.cluster_centers_[label, 0], kmeans.cluster_centers_[label, 1]),
                color = 'b', fontsize = 20)

ax.set_title('Cluster Centers of NYC')
plt.show()
# --- 2. 전체 데이터에 클러스터 ID 부여 (Feature Engineering) ---
# 학습된 모델을 이용해 '승차 구역'과 '하차 구역'을 예측하여 새로운 컬럼으로 저장
df['pickup_cluster'] = kmeans.predict(df[['pickup_longitude', 'pickup_latitude']])
df['dropoff_cluster'] = kmeans.predict(df[['dropoff_longitude', 'dropoff_latitude']])
# --- 3. 날짜 문자열에서 '시간(Hour)' 정보 추출 ---
df['pickup_hour'] = df.pickup_datetime.apply(lambda x: parser.parse(x).hour)
# 1. 클러스터 중심점 데이터프레임 생성
clusters = pd.DataFrame()
clusters['x'] = kmeans.cluster_centers_[:, 0]
clusters['y'] = kmeans.cluster_centers_[:, 1]
clusters['label'] = range(len(clusters))

# 2. 배경으로 쓸 샘플 데이터 (너무 많으면 느리므로 5000개만)
loc_df_sample = loc_df.sample(5000)

# 3. 애니메이션 함수 정의
fig, ax = plt.subplots(1, 1, figsize=(10, 10))

def animate(hour):
    ax.clear()
    ax.set_title('Absolute Traffic - Hour ' + str(int(hour)) + ':00')
    
    # 3-1. 배경 그리기 (회색 점: 도시 전체 윤곽, 빨간 점: 클러스터 중심)
    # 주의: plt.figure()는 애니메이션 루프 안에서 호출하면 안 됩니다. (창이 계속 뜸)
    for label in loc_df_sample.label.unique():
        ax.plot(loc_df_sample.longitude[loc_df_sample.label == label],
                loc_df_sample.latitude[loc_df_sample.label == label],
                '.', alpha=0.4, markersize=2, color='gray')
        ax.plot(kmeans.cluster_centers_[label, 0],
                kmeans.cluster_centers_[label, 1],
                'o', color='r')

    # 3-2. 교통 흐름 그리기 (핵심 로직!)
    # 출발지(label) -> 도착지(dest_label)로 가는 택시 수(num_of_rides) 계산
    for label in clusters.label:
        for dest_label in clusters.label:
            # 해당 시간대(hour)에 특정 경로(A->B)로 이동한 택시 수 계산
            num_of_rides = len(df[(df.pickup_cluster == label) & 
                                  (df.dropoff_cluster == dest_label) & 
                                  (df.pickup_hour == hour)])

            # 택시가 이동한 거리 계산 (x, y 좌표 차이)
            dist_x = clusters.x[clusters.label == label].values[0] - clusters.x[clusters.label == dest_label].values[0]
            dist_y = clusters.y[clusters.label == label].values[0] - clusters.y[clusters.label == dest_label].values[0]
            
            # 이동 횟수(num_of_rides)가 0보다 클 때만 화살표 그리기
            if num_of_rides > 0:
                pct = np.true_divide(num_of_rides, len(df[df.pickup_hour == hour]))
                
                # 화살표 그리기 (교통량이 많을수록 굵고 진하게)
                # alpha: 투명도, width: 화살표 두께
                arr = arrow(clusters.x[clusters.label == label].values[0], 
                            clusters.y[clusters.label == label].values[0], 
                            -dist_x, 
                            -dist_y, 
                            edgecolor='white', 
                            width = num_of_rides/10000, # 두께 조절 (데이터 양에 따라 조절 필요)
                            alpha = pct * 2 # 투명도 조절
                           )
                ax.add_patch(arr)

# 4. 애니메이션 실행 (0시부터 23시까지)
ani = animation.FuncAnimation(fig, animate, sorted(df.pickup_hour.unique()), interval=1000)
plt.close() # 정적 이미지가 중복 출력되는 것 방지

# 5. 애니메이션 출력 (HTML로 변환)
HTML(ani.to_html5_video())

from matplotlib.patches import Arrow  # Arrow 패치 임포트 필요

def animate(hour):
    ax.clear()
    ax.set_title('Absolute Traffic - Hour ' + str(int(hour)) + ':00')    
    
    # 1. 배경 (회색 점) 및 클러스터 중심 (빨간 점) 그리기
    for label in loc_df.label.unique():
        ax.plot(loc_df.longitude[loc_df.label == label],
                loc_df.latitude[loc_df.label == label],
                '.', alpha=1, markersize=2, color='gray')
        ax.plot(kmeans.cluster_centers_[label, 0],
                kmeans.cluster_centers_[label, 1],
                'o', color='r')

    # 2. 화살표 그리기 (교통 흐름)
    for label in clusters.label:
        for dest_label in clusters.label:
            # 해당 시간대, 출발지->도착지 이동 데이터 필터링
            filtered_df = df[(df.pickup_cluster == label) & 
                             (df.dropoff_cluster == dest_label) & 
                             (df.pickup_hour == hour)]
            
            num_of_rides = len(filtered_df)

            # 이동 거리가 있고, 탑승객이 있는 경우에만 화살표 생성
            if num_of_rides > 0:
                # 거리 계산 (Vector Calculation)
                start_x = clusters.x[clusters.label == label].values[0]
                start_y = clusters.y[clusters.label == label].values[0]
                dest_x = clusters.x[clusters.label == dest_label].values[0]
                dest_y = clusters.y[clusters.label == dest_label].values[0]
                
                dist_x = start_x - dest_x
                dist_y = start_y - dest_y
                
                # 화살표 두께 설정 (비중 기반)
                pct = np.true_divide(num_of_rides, len(df))
                
                # Arrow(x, y, dx, dy, ...) 주의: dx, dy는 '변화량'
                # 여기서는 도착지 방향으로 그리기 위해 -dist_x, -dist_y 사용
                arr = Arrow(start_x, start_y, -dist_x, -dist_y, 
                            edgecolor='white', width=15*pct)
                
                ax.add_patch(arr)
                arr.set_facecolor('g') # 초록색 화살표

# --- 애니메이션 생성 및 저장 ---
ani = animation.FuncAnimation(fig, animate, sorted(df.pickup_hour.unique()), interval=1000)
plt.close() # 정적 플롯 닫기

# GIF 저장 (ImageMagick이 없다면 writer='pillow' 추천)
ani.save('animation.gif', writer='pillow', fps=2)

# --- HTML로 출력 (Colab/Kaggle용) ---
filename = 'animation.gif'
video = io.open(filename, 'r+b').read()
encoded = base64.b64encode(video)
HTML(data='''<img src="data:image/gif;base64,{0}" type="gif" />'''.format(encoded.decode('ascii')))

from matplotlib.patches import Arrow

# 1. 캔버스 설정
fig, ax = plt.subplots(1, 1, figsize=(10, 10))

def animate(hour):
    ax.clear()
    # 제목: 시간대별 상대적 교통량
    ax.set_title('Relative Traffic - Hour ' + str(int(hour)) + ':00')
    
    # 2. 배경 그리기 (회색 점: 도시 윤곽, 빨간 점: 클러스터 중심)
    for label in loc_df.label.unique():
        ax.plot(loc_df.longitude[loc_df.label == label],
                loc_df.latitude[loc_df.label == label],
                '.', alpha=0.6, markersize=2, color='gray')
        ax.plot(kmeans.cluster_centers_[label, 0],
                kmeans.cluster_centers_[label, 1],
                'o', color='r')

    # 3. 화살표 그리기 (핵심: 상대적 비율 pct 사용)
    for label in clusters.label:
        for dest_label in clusters.label:
            # 해당 시간대(hour) 전체 운행 건수
            total_rides_hour = len(df[df.pickup_hour == hour])
            
            # 해당 경로(A->B) 운행 건수
            rides_on_route = df[(df.pickup_cluster == label) & 
                                (df.dropoff_cluster == dest_label) & 
                                (df.pickup_hour == hour)]
            num_of_rides = len(rides_on_route)

            # 이동 데이터가 있을 때만 화살표 생성
            if num_of_rides > 0 and total_rides_hour > 0:
                # 좌표 차이 계산 (Vector)
                start_x = clusters.x[clusters.label == label].values[0]
                start_y = clusters.y[clusters.label == label].values[0]
                dest_x = clusters.x[clusters.label == dest_label].values[0]
                dest_y = clusters.y[clusters.label == dest_label].values[0]
                
                dist_x = start_x - dest_x
                dist_y = start_y - dest_y
                
                # 비율(Percentage) 계산 -> 화살표 두께로 사용
                pct = num_of_rides / total_rides_hour
                
                # Arrow(x, y, dx, dy, width)
                # width에 상수를 곱해(예: pct*15) 시각적으로 더 잘 보이게 조정 가능
                arr = Arrow(start_x, start_y, -dist_x, -dist_y, 
                            edgecolor='white', width=pct)
                
                ax.add_patch(arr)
                arr.set_facecolor('g') # 초록색 화살표

# 4. 애니메이션 생성 및 저장
# interval=1000: 1초에 한 프레임(1시간)씩 넘어감
ani = animation.FuncAnimation(fig, animate, sorted(df.pickup_hour.unique()), interval=1000)
plt.close() # 정적 플롯 닫기

# GIF 저장 (ImageMagick 없을 시 'pillow' 사용)
ani.save('animation.gif', writer='pillow', fps=2)

# 5. 결과 출력 (HTML)
filename = 'animation.gif'
video = io.open(filename, 'r+b').read()
encoded = base64.b64encode(video)
HTML(data='''<img src="data:image/gif;base64,{0}" type="gif" />'''.format(encoded.decode('ascii')))

# 1. (경도, 위도)를 키(Key)로 갖는 딕셔너리로 수정
neighborhood = {
    (-74.0019, 40.7465): 'Chelsea',
    (-73.8375, 40.7128): 'Queens',
    (-73.7854, 40.6413): 'JFK',
    (-73.9810, 40.7655): 'Midtown-North-West',
    # ... (나머지 지역도 위도 추가 필요)
}

# 2. 학습 데이터 준비
X = np.array(list(neighborhood.keys())) # (경도, 위도) 쌍
y = list(neighborhood.values())         # 동네 이름

# 3. KNN 모델 학습
neigh = KNeighborsClassifier(n_neighbors=1)
neigh.fit(X, y)

# 4. 예측 (Predict) 예시
# 새로운 택시 좌표 [-73.98, 40.75]가 들어왔을 때 어디인지 맞춤
print(neigh.predict([[-73.98, 40.75]]))

# 승차(Pickup) 및 하차(Dropoff) 위치의 동네 예측
# .values.reshape(-1, 1): 시리즈를 2차원 배열로 변환 (sklearn 입력 형식)
df['pickup_neighborhood'] = neigh.predict(df.pickup_longitude.values.reshape(-1,1))
df['dropoff_neighborhood'] = neigh.predict(df.dropoff_longitude.values.reshape(-1,1))

# 각 동네별(x) 도착지(col)로 향하는 택시 운행 횟수 계산
for col in rides_df.columns[:-1]: # 마지막 컬럼인 'name' 제외
    rides_df[col] = rides_df.name.apply(lambda x: len(df[(df.pickup_neighborhood == x) & (df.dropoff_neighborhood == col)]))

# 각 동네별(x) 도착지(col)로 향하는 택시 운행 횟수 계산
for col in rides_df.columns[:-1]: # 마지막 컬럼인 'name' 제외
    rides_df[col] = rides_df.name.apply(lambda x: len(df[(df.pickup_neighborhood == x) & (df.dropoff_neighborhood == col)]))

import plotly.offline as py
import plotly.graph_objs as go
py.init_notebook_mode(connected=True)

# 히트맵 데이터 설정
# z: 이동 횟수 데이터 (수치형 컬럼만 선택)
# x: 도착지 (To)
# y: 출발지 (From)
trace = go.Heatmap(
    z = np.array(rides_df.iloc[:, :-1].values),  # .as_matrix()는 구버전, .values 권장
    x = rides_df.columns[:-1],
    y = rides_df.name 
)

# 레이아웃 설정
layout = dict(
    title = '<b>Neighborhoods Interaction</b>',
    titlefont = dict(
        size = 30,
        color = ('rgb(100,100,100)')
    ),
    margin = dict(t=100, r=100, b=100, l=150),
    yaxis = dict(title = '<b> From </b>'),
    xaxis = dict(title = '<b> To </b>')
)

# 그래프 출력
data = [trace]
fig = go.Figure(data=data, layout=layout)
py.iplot(fig, filename='labelled-heatmap')

# 1. 캔버스 크기 설정 (12x12 인치)
fig, ax = plt.subplots(figsize = (12,12))

# 2. 히트맵 그리기
# 'name' 컬럼은 문자열이므로 시각화에서 제외(drop)해야 합니다.
cax = ax.matshow(rides_df.drop('name', axis=1), interpolation='nearest', cmap=cm.afmhot)

# 3. 컬러바(범례) 추가
cbar = fig.colorbar(cax)

# 4. 그리드 끄기 (히트맵은 격자선이 없는 게 깔끔함)
ax.grid(False)

# 5. 축 눈금 및 라벨 설정
# X축: 도착지 (To)
ax.set_xticks(range(len(rides_df)))
ax.set_xticklabels(rides_df.name, rotation=90, fontsize=15)

# Y축: 출발지 (From)
ax.set_yticks(range(len(rides_df)))
ax.set_yticklabels(rides_df.name, fontsize=15)

# 6. 축 제목 및 전체 제목 설정
ax.set_xlabel('To (Destination)', fontsize=25)
ax.set_ylabel('From (Origin)', fontsize=25)
ax.set_title('Neighborhoods Interaction', y=1.1, fontsize=30) # y=1.1로 제목을 그래프 위로 조금 띄움

plt.show()

# 1. 데이터프레임 인덱스 정리
# 'name' 컬럼을 인덱스로 설정하여 계산 편의성 확보
rides_df.index = rides_df.name
rides_df = rides_df.drop('name', axis=1)

# 2. 시각화: 유입(Inbound) vs 유출(Outbound) 산점도
fig, ax = plt.subplots(figsize=(12, 12))

# 각 동네별로 점 찍기
for i in range(len(rides_df)):
    # axis=1 (행 합계): Outbound (출발)
    outbound_count = rides_df.sum(axis=1)[i]
    
    # axis=0 (열 합계): Inbound (도착)
    inbound_count = rides_df.sum(axis=0)[i]
    
    # 점 그리기
    ax.plot(outbound_count, inbound_count, 'o', color='b')
    
    # 동네 이름 텍스트 추가 (Annotation)
    ax.annotate(rides_df.index.tolist()[i], 
                (outbound_count, inbound_count), 
                color='b', fontsize=12)

# 3. 기준선 (Reference Line, y=x) 그리기
# 이 선 위에 있으면 유입과 유출이 균형을 이루는 상태
ax.plot([0, 250000], [0, 250000], color='r', linewidth=1)

# 4. 그래프 스타일 설정
ax.grid(False)
ax.set_xlim([0, 250000])
ax.set_ylim([0, 250000])
ax.set_xlabel('Outbound Taxis (Departures)')
ax.set_ylabel('Inbound Taxis (Arrivals)')
ax.set_title('Inbound and Outbound rides for each cluster', fontsize=15)

plt.show()

# --- Feature Engineering: 월(Month) 정보 추출 ---
# (참고: 데이터가 많다면 parser보다 pd.to_datetime().dt.month가 훨씬 빠릅니다)
df['pickup_month'] = df.pickup_datetime.apply(lambda x: parser.parse(x).month)

# 1. 캔버스 설정 (위아래 2개 그래프 생성)
fig, ax = plt.subplots(2, figsize=(12, 12))

# --- [그래프 1] 6월 (June) 데이터 분석 ---

# 1-1. 6월 데이터로 동네별 이동량 계산
for col in rides_df.columns[:-1]: # 'name' 컬럼 제외
    rides_df[col] = rides_df.name.apply(lambda x: len(df[
        (df.pickup_neighborhood == x) & 
        (df.dropoff_neighborhood == col) & 
        (df.pickup_month == 6) # 6월 필터링
    ]))

# 1-2. 6월 시각화
for i in range(len(rides_df)):
    # Outbound (x축) vs Inbound (y축) 점 찍기
    ax[0].plot(rides_df.sum(axis=1)[i], rides_df.sum(axis=0)[i], 'o', color='b')
    
    # 동네 이름 주석 달기
    ax[0].annotate(rides_df.index.tolist()[i], 
                   (rides_df.sum(axis=1)[i], rides_df.sum(axis=0)[i]), 
                   color='b', fontsize=12)

# 1-3. 그래프 스타일 설정
ax[0].grid(False)
ax[0].set_xlabel('Outbound Taxis (Departures)')
ax[0].set_ylabel('Inbound Taxis (Arrivals)')
ax[0].set_title('Inbound and Outbound rides for each cluster - June (Summer)')
ax[0].set_xlim([0, 40000])
ax[0].set_ylim([0, 40000])
ax[0].plot([0, 40000], [0, 40000], color='r') # 기준선 y=x


# --- [그래프 2] 1월 (January) 데이터 분석 ---

# 2-1. 1월 데이터로 동네별 이동량 재계산
for col in rides_df.columns[:-1]:
    rides_df[col] = rides_df.name.apply(lambda x: len(df[
        (df.pickup_neighborhood == x) & 
        (df.dropoff_neighborhood == col) & 
        (df.pickup_month == 1) # 1월 필터링
    ]))

# 불필요한 'name' 컬럼 제거 (수치 계산 오류 방지)
rides_df = rides_df.drop('name', axis=1)

# 2-2. 1월 시각화
for i in range(len(rides_df)):
    ax[1].plot(rides_df.sum(axis=1)[i], rides_df.sum(axis=0)[i], 'o', color='b')
    ax[1].annotate(rides_df.index.tolist()[i], 
                   (rides_df.sum(axis=1)[i], rides_df.sum(axis=0)[i]), 
                   color='b', fontsize=12)

# 2-3. 그래프 스타일 설정
ax[1].grid(False)
ax[1].set_xlabel('Outbound Taxis (Departures)')
ax[1].set_ylabel('Inbound Taxis (Arrivals)')
ax[1].set_title('Inbound and Outbound rides for each cluster - January (Winter)')
ax[1].set_xlim([0, 40000])
ax[1].set_ylim([0, 40000])
ax[1].plot([0, 40000], [0, 40000], color='r') # 기준선 y=x
